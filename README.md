Glasgow
-------

An easy-to-use JavaScript library for building user interfaces in a *functional reactive* way, using JSX.

Some advantages:

- *Easy* to learn, as it is low on concepts.

- *Easy* state mangement: you can store state anywhere you like. There's no `setState`. The UI will refresh automatically after handling events, or when you tell it to. Component-local state is supported as well, and is just as easy.

- *Easy* event handling.
  - Binding is usually not required, as handlers will be provided with relevant context by default.
  - Event delegation, meaning performance won't suffer much if you *do* need to bind or create new function instances on each refresh.
  - Two-way bindings, when you want them.

- *Tiny*. Less than 3kb minified and gzipped. Built from a single source file that is small enough to read. No dependencies.

- *Fast*, in most cases, probably, I guess. :-) No benchmarks yet, though.

Some disadvantages:

- Experimental. You probably shouldn't build your business around this.

- Only the basics. No routers, no server-side rendering, no ready-to-use components.

- If you want to use JSX, you need to transpile your source code.



## Example usage

```javascript
// First we'll instruct the JSX compiler to generate `glasgow(..)` calls:
/** @jsx glasgow */


// I'm using global state here for the list. We could have also chosen to pass
// the state down the chain, but I want to stress the point that nothing
// special is going on here.
let list = [];


// This is the component for list items. Components are just functions.
// A component gets a (JSX) attributes object and an array of children (which // we're ignoring here).
function Item(props, children) {
  return <li>
    <div class="text">{props.key}</div>
    <div class="delete" onclick={deleteItem}>x</div>
  </li>;
}

// This the onclick handler for the delete-button. Notice how we didn't need to
// bind the function, as `info` provides us access to the component's `props`,
// among other things.
function deleteItem(info) {
  // We're just modifying regular JavaScript variables here. Glasgow will 
  // refresh the UI after we return from the event handler.
  list.splice(list.indexOf(info.context.item), 1);
}


// This is our main component.
function ToDo(props, children) {
  // The JavaScript `map` function is used to translate the list of ToDo-items 
  // into a list of virtual DOM elements.
  // `key` is kind of a special attribute, as it's also used to match-up old
  // elements with new elements when doing a refresh.
  return <main>
    <h1>Mandatory ToDo example</h1>
    <ul>
      {list.map(item => <Item key={item} />)}
    </ul>
    <input type="text" placeholder="New item" binding="$newItem" />
    <input type="button" value="Add" onclick={addItem} />
  </main>;
  // We're binding the text input to `$newItem`, meaning it is synced with
  // `props.$newItem`.
  // The $-sign indicates that this is a state-variable, which means that its
  // value is kept when redrawing.
}

function addItem(info) {
  list.push(info.props.$newItem);
  info.props.$newItem = "";
}


// And this is where we add the ToDo component to the DOM. Presto!
tearea.mount(document.body, ToDo);
```


## Installation

Apart from installing and importing this library, you'll need to setup *babel* to transpile JSX to plain JavaScript. Sorry, no details instructions yet.



## Reference manual

### The glasgow module

This is the function obtained by importing glasgow.

```javascript
const glasgow = require('glasgow');
```

Or

```javascript
import glasgow from 'glasgow';
```

#### glasgow(tag, props, ..children)

Calls to this method are usually generated by the JSX compiler. But you're free to skip JSX entirely and make these calls yourself.

The function returns a virtual DOM node.

- `tag` is either a string containing an HTML element tag (like "div" or "a"), or a function, which will be used as a component. (See: Components.)

- `props` is an optional JavaScript object containing HTML attributes. Some special cases:
  - `className`, `checked`, `value` and `selectedIndex` are DOM properties instead of HTML attributes. `null` values are ignored.
  - `style` can receive a style properties object instead of a style string.
  - Attributes starting with `on` are assumed to be event handlers. (See: Event handlers.)
  - `key`, `binding` and attributes starting with `_` are not set as HTML attributes.
  
  Of course, when `tag` is a function, none of this applies, and the `props` are just passed as the first argument to this component function.

- `children` is an optional array of (arrays of) virtual DOM nodes. `null` values are ignored.

##### Example

```javascript
function MyLink(props, children) {
  return glasgow('a', {
    href: 'https://github.com/vanviegen/glasgow',
    target: props.newWindow ? '_blank' : null,
  }, children);
}
  
glasgow('main', {},
  glasgow('h1', {}, 'Welcome'),
  glasgow(MyLink, {newWindow: true}, 'Fork me here!')
);
```

#### glasgow.mount(domParent, component)

Mount the component to the DOM, returning a glasgow instance. (See: Instances.)

- `domParent` is just a DOM element to which a single child will be appended.
- `component` is either a component function, or a virtual DOM.

##### Examples

```javascript
let instance = glasgow.mount(document.body, MyComponent);
```

```javascript
let instance = glasgow.mount(document.body, <MyComponent foo={bar} />);
```



### Instances

An instance object is returned by `glasgow.mount(..)`. It has these methods:

#### instance.refresh()

Schedules an asynchronous refresh. This happens automatically after handling a glasgow-event. In case data was modified at another time (for instance when arriving from the server), you'll want to call refresh. 

#### instance.refreshNow()

Refresh synchronously.

#### instance.refreshify(func)

Just a little utility that returns a function wrapping `func`. It will make sure `refresh()` gets called after every function invocation. And in case `func` returns a Promise, it'll fire again when the Promise is fulfilled. 

#### instance.fetch(...)

Just a convenient `refreshify(window.fetch)`. If you need to polyfill the `fetch` API (you're support Internet Explorer), make sure the polyfill is loaded before you `mount`.

#### instance.afterRefresh(func)

Schedule `func` to be called one time immediately after the refresh cycle is done, but before returning control back to the browser. This is useful when you want to do some direct DOM manipulation based on the complete layout. 

#### instance.unmount()

Remove the glasgow instance from the DOM, calling any `onremove` handlers.

#### instance.getTree()

Returns the currently rendered virtual DOM tree. (See: Virtual DOM nodes.) This should only be used for debugging. The format may change in minor releases.



### Event handlers

Events can be registered on any HTML virtual DOM node (meaning: *not* on components) using `on...` attributes with functions as values. For example:

```javascript
<div onclick={info => console.log(info)}>Click me</div>
```

The event handler function receives an object as its only argument, containing:

- `props`: the properties object of the component containing this DOM element.
- `event`: the DOM event.
- `element`: the DOM element that received the event.
- `node`: the virtual DOM node (containing the attributes) for the DOM element that received the event.
- `instance`: the glasgow instance. (See: Instances.)

When the event handler returns anything other than `glasgow.NOT_HANDLED`, the event will not propagate further up the tree, and `preventDefault()` will be called on it.

#### Event delegation

As glasgow uses event delegation, `addEventListener` will only be called once per event type, on the root element of the instance.

Because of this, having lots of event handlers in your tree will not require them to be reattached on every refresh, even when you're creating new bindings or new function instances in each refresh.

#### oncreate *(unstable)*

`oncreate` is a special case event, as it is not a DOM event. It is fired right after a DOM element is created, but before its properties are set or it is attached to the parent. It receives an object as its only argument, containing:

- `props`: the properties object of the component containing this DOM element.
- `element`: the DOM element that was created.
- `node`: the virtual DOM node (containing the attributes) for the new DOM element.
- `instance`: the glasgow instance. (See: Instances.)
- `parentStable`: boolean indicating whether the parent DOM element already existed earlier (`true`) or was also just created in this refresh (`false`). This is mostly useful for fade-in transitions and such.

This method is marked **unstable** because I'm considering changing semantics on this in the at some point.

#### onremove *(unstable)*

`onremove` is a special case event, as it is not a DOM event. It is fired right befoe an element is removed from the DOM. It receives an object as its only argument, containing:

- `props`: the properties object of the component containing this DOM element.
- `node`: the virtual DOM node (containing the attributes) for the to-be-removed DOM element.
- `instance`: the glasgow instance. (See: Instances.)
- `parentStable`: boolean indicating whether the parent element will remain in the DOM (`true`) or will also be removed during this refresh (`false`). This is mostly useful for fade-out transitions and such.
- `element`: the DOM element that is to be removed, but only when `parentStable == true`.


When `parentStable == true` and the event handler returns `glasgow.KEEP`, the element will be preserved in the DOM (and in the virtual DOM) for now. This can be used to implement fade-out transitions.

This method is marked **unstable** because I'm considering changing semantics on this in the at some point.



### Virtual DOM nodes

There are two types of virtual DOM nodes:

- Objects returned by the `glasgow(...)` function. These are in fact just the properties objects, augmented with some underscore-prefixed keys that are implementation details to glasgow. You'll find keys like `_t` for tag, `_c` for children, and `_a` for the materialized tree of a component. You should not rely on these, as their semantics may change in minor releases.

- Plain old JavaScript string, which are rendered to DOM `TextNode`s.



### Components

Components are just JavaScript functions that return a virtual DOM node. They receive two arguments:

- `props`: a properties object, based on the JSX attributes. There are two special cases of properties, their keys starting with..
  - `$`: these are state variables. (See: Component state.)
  - `_`: these are glasgow internals (such as `_t` for the tag and `_c` for children). You shouldn't rely on these, as their semantics may change in minor releases.
- `children`: a (possibly empty) array of virtual DOM nodes. In case, as is common, your component doesn't need to display any caller-specified *content HTML*, you can just ignore this. For example, one can imagine a `PageTemplate` component receiving content. But a `Thumbnail` component probably woudn't.

#### Component state

State variables can be (but do not need to) specified as attributes by the caller like any other property. The difference with other properties, is that when you change their value (for instance from within a component function, a event handler or using a binding), glasgow tries to preserve their value across refreshes. For example:

```javascript
function RefreshCounter(props) {
  if (!props.$count) props.$count = 1;
  return (props.$count++).toString();
}
```
This example increments the number shown every time glasgow refreshes the UI. Of course, this kind-of breaks the one-way flow of information that makes reactive functional UI programming so easy to reason about. A rule of thumb is that you should only use local state for augmenting the information you received by means of regular `props`. For example, one can load additional information (say the last-online-time for `props.userId`) from a server and store it as `props.$lastOnline`.

But how does glasgow know when the preserve state, and when a component that is generated in a refresh is actually ment to operate on different data?

- The first step is that glasgow must be able to match the component and all its ancestor elements and components to their versions in the previous refresh. It does this by matching tags and components based on their position within the parent, or based on keys when available. (This matching is not only done for preserving state, but is also crucial in preventing having to redraw the entire interface on every refresh.) If you're loosing state when elements are moving around in your user interface, it may help to add some keys to the moving elements and components.

- But even after matching a component with a component of the same type from the previous refresh, state will not always be preserved. This will only happen when all of the `props` (except those starting with `$` or `_`) are *exactly* identical. A property referring to a different object or array that does have the same contents does *not* count as identical.

When it is determined that state can safely be preserved, the old `props` object is moved into the new refresh's tree. This allows you to do things like this without refreshes during the fetch causing problems:

```javascript
function Fetcher(props) {
  if (!props.$fetching) {
    props.$fetching = true;
    this.fetch(props.url)
      .then(resp => resp.text())
      .then(text => props.$data = text);
  }
  return props.$data==null ? <em>Loading...</em> : props.$data;
}
```



### Bindings *(incomplete)*

Bindings are a shortcut for setting an `oninput` event handler and a initial value on an HTML `input` (or `textarea`, or `select`) element. This creates a two-way binding between the application data and the UI view. The value for binding can be:

- A `binding` string. In this case the input is bound to `props[binding]`, where `props` is the properties object for the containing component. In case the string contains dots, they are used to go deeper into your data tree. Any non-existing nodes are created as empty objects. For example: `<input binding="myData.list.14" />` will bind the input to `props.myData.list[14]`. If they didn't exist yet, `myData` and `list` will be created as empty objects.

- A two-element `binding` array. You can use this to bind to arbitrary data outside of the components `props`. For example `<input binding={[myGlobalList,135]} />`.

Bindings support should be considered **incomplete**, as not all input types are supported yet. At least `textarea` and `input` types `text`, `password`, `checkbox` and `number` *do* work. Feel free to file bugs (or pull requests!) for other types if you need them.
